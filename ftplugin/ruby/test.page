


    #   -------------"_--------------- 
    #  "`wrapped^"                     



"WRAPPED_TEXT
WRAPPED_TEXT_line2"

"WRAPPED_TEXT
WRAPPED_TEXT_line2"b

a "WRAPPED_TEXT
WRAPPED_TEXT_line2"b

a "WRAPPED_TEXT
WRAPPED_TEXT_line2"


    #   -------------%--------------- 
    #  %`_^[`^]                       



    %w[]

    %w[_TYPED] b

    a %w[] b

    a %w[]


    #   -------------'_--------------- 
    #  '`wrapped^'                     



'WRAPPED_TEXT
WRAPPED_TEXT_line2'

'WRAPPED_TEXT
WRAPPED_TEXT_line2'b

a 'WRAPPED_TEXT
WRAPPED_TEXT_line2'b

a 'WRAPPED_TEXT
WRAPPED_TEXT_line2'


    #   -------------(_--------------- 
    #  (`wrapped^)                     



(WRAPPED_TEXT
WRAPPED_TEXT_line2)

(WRAPPED_TEXT
WRAPPED_TEXT_line2)b

a (WRAPPED_TEXT
WRAPPED_TEXT_line2)b

a (WRAPPED_TEXT
WRAPPED_TEXT_line2)


    #   -------------:--------------- 
    #  :`key^ => `value^              



    :key => value

    :key_TYPED => value b

    a :key => value b

    a :key => value


    #   -------------<_--------------- 
    #  <`wrapped^>                     



<WRAPPED_TEXT
WRAPPED_TEXT_line2>

<WRAPPED_TEXT
WRAPPED_TEXT_line2>b

a <WRAPPED_TEXT
WRAPPED_TEXT_line2>b

a <WRAPPED_TEXT
WRAPPED_TEXT_line2>


    #   -------------[_--------------- 
    #  [`wrapped^]                     



[WRAPPED_TEXT
WRAPPED_TEXT_line2]

[WRAPPED_TEXT
WRAPPED_TEXT_line2]b

a [WRAPPED_TEXT
WRAPPED_TEXT_line2]b

a [WRAPPED_TEXT
WRAPPED_TEXT_line2]


    #   -------------_d--------------- 
    #  __DATA__                        



    __DATA__

    __DATA__ b

    a __DATA__ b

    a __DATA__


    #   -------------_e--------------- 
    #  __END__                         



    __END__

    __END__ b

    a __END__ b

    a __END__


    #   -------------_f--------------- 
    #  __FILE__                        



    __FILE__

    __FILE__ b

    a __FILE__ b

    a __FILE__


    #   -------------`_--------------- 
    #  \``wrapped^\`                   



`WRAPPED_TEXT
WRAPPED_TEXT_line2`

`WRAPPED_TEXT
WRAPPED_TEXT_line2`b

a `WRAPPED_TEXT
WRAPPED_TEXT_line2`b

a `WRAPPED_TEXT
WRAPPED_TEXT_line2`


    #   -------------ali--------------- 
    #  alias :`new^ :`old^              



    alias :new :old_new

    alias :new_TYPED :old_TYPED b

    a alias :new :old_new b

    a alias :new :old_new


    #   -------------all--------------- 
    #  all? { |`element^| `cursor^ }    



    all? { |element|  }

    all? { |element_TYPED|  } b

    a all? { |element|  } b

    a all? { |element|  }


    #   -------------amm--------------- 
    #  alias_method :`new^, :`old^      



    alias_method :new, :old_new

    alias_method :new_TYPED, :old_TYPED b

    a alias_method :new, :old_new b

    a alias_method :new, :old_new


    #   -------------any--------------- 
    #  any? { |`element^| `cursor^ }    



    any? { |element|  }

    any? { |element_TYPED|  } b

    a any? { |element|  } b

    a any? { |element|  }


    #   -------------app--------------- 
    #  if __FILE__ == $PROGRAM_NAME     
    #      `cursor^                     
    #  end                              



    if __FILE__ == $PROGRAM_NAME
        
    end

    if __FILE__ == $PROGRAM_NAME
        
    end b

    a if __FILE__ == $PROGRAM_NAME
        
    end b

    a if __FILE__ == $PROGRAM_NAME
        
    end


    #   -------------array---------------   
    #  Array.new(`size^) { |`i^| `cursor^ } 



    Array.new(size) { |i|  }

    Array.new(size_TYPED) { |i_TYPED|  } b

    a Array.new(size) { |i|  } b

    a Array.new(size) { |i|  }


    #   -------------ass--------------- 
    #  assert`_`what^                   



    assert_block {  }

    assert_block {  } b

    a assert_block {  } b

    a assert_block {  }


    #   -------------attr--------------- 
    #  attr`_`what^ :`attr*^             



    attr_accessor :

        attr_accessor :attr_TYPED, :attr_TYPED, :attr_TYPED b

    a attr_accessor : b

    a attr_accessor :


    #   -------------Author--------------- 
    #  `$author^                           



    drdr.xp

    drdr.xp b

    a drdr.xp b

    a drdr.xp


    #   -------------BEG--------------- 
    #  BEGIN {                          
    #      `cursor^                     
    #  }                                



    BEGIN {
        
    }

    BEGIN {
        
    } b

    a BEGIN {
        
    } b

    a BEGIN {
        
    }


    #   -------------begin--------------- 
    #  begin                              
    #      `expr^                         
    #  ``rescue...`                       
    #  {{^rescue `Exception^` => `e^      
    #      `block^                        
    #  ``rescue...`                       
    #  ^`}}^``else...`                    
    #  {{^else                            
    #      `block^                        
    #  `}}^``ensure...`                   
    #  {{^ensure                          
    #      `cursor^                       
    #  `}}^end                            



    begin
        expr
    rescue Exception => e
        # block
    rescue Exception => e
        # block
    rescue Exception => e
        # block
    else
        # block
    ensure
        
    end

    begin
        expr_TYPED
    rescue_TYPED
    else_TYPED
    ensure_TYPED
    end b

    a begin
        expr
    rescue Exception => e
        # block
    rescue Exception => e
        # block
    rescue Exception => e
        # block
    else
        # block
    ensure
        
    end b

    a begin
        expr
    rescue Exception => e
        # block
    rescue Exception => e
        # block
    rescue Exception => e
        # block
    else
        # block
    ensure
        
    end


    #   -------------begin_--------------- 
    #  begin                               
    #      `wrapped^                       
    #  ``rescue...`                        
    #  {{^rescue `Exception^` => `e^       
    #      `block^                         
    #  ``rescue...`                        
    #  ^`}}^``else...`                     
    #  {{^else                             
    #      `block^                         
    #  `}}^``ensure...`                    
    #  {{^ensure                           
    #      `cursor^                        
    #  `}}^end                             



begin
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
rescue Exception => e
    # block
rescue Exception => e
    # block
rescue Exception => e
    # block
else
    # block
ensure
    
end

begin
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
rescue_TYPED
else_TYPED
ensure_TYPED
endb

a begin
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
rescue Exception => e
    # block
rescue Exception => e
    # block
rescue Exception => e
    # block
else
    # block
ensure
    
endb

a begin
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
rescue Exception => e
    # block
rescue Exception => e
    # block
rescue Exception => e
    # block
else
    # block
ensure
    
end


    #   -------------bm--------------- 
    #  TESTS = `times^                 
    #                                  
    #  Benchmark.bmbm do |result|      
    #      `cursor^                    
    #  end                             



    TESTS = 10_000
    
    Benchmark.bmbm do |result|
        
    end

    TESTS = times_TYPED
    
    Benchmark.bmbm do |result|
        
    end b

    a TESTS = 10_000
    
    Benchmark.bmbm do |result|
        
    end b

    a TESTS = 10_000
    
    Benchmark.bmbm do |result|
        
    end


    #   -------------case--------------- 
    #  case `target^`                    
    #  when `comparison^                 
    #      `block^                       
    #  ``when...`                        
    #  {{^when `comparison^              
    #      `block^                       
    #  ``when...`                        
    #  ^`}}^``else...`                   
    #  {{^else                           
    #      `cursor^                      
    #  `}}^end                           



    case target
    when comparison
        # block
    when comparison
        # block
    when comparison
        # block
    when comparison
        # block
    else
        
    end

    case target_TYPED
    when comparison_TYPED
        block_TYPED
    when_TYPED
    else_TYPED
    end b

    a case target
    when comparison
        # block
    when comparison
        # block
    when comparison
        # block
    when comparison
        # block
    else
        
    end b

    a case target
    when comparison
        # block
    when comparison
        # block
    when comparison
        # block
    when comparison
        # block
    else
        
    end


    #   -------------cfy---------------  
    #  classify { |`element^| `cursor^ } 



    classify { |element|  }

    classify { |element_TYPED|  } b

    a classify { |element|  } b

    a classify { |element|  }


    #   -------------cl--------------- 
    #  class `ClassName^               
    #      `cursor^                    
    #  end                             



    class ClassName
        
    end

    class ClassNameTYPED
        
    end b

    a class ClassName
        
    end b

    a class ClassName
        
    end


    #   -------------class_--------------- 
    #  class `_^                           
    #      `wrapped^                       
    #  end                                 



class 
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
end

class TYPED
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
endb

a class 
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
endb

a class 
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
end


    #   -------------cld---------------                 
    #  class `ClassName^ < DelegateClass(`ParentClass^) 
    #      def initialize`(`arg*`)^                     
    #          super(`delegate object^)                 
    #                                                   
    #          `cursor^                                 
    #      end                                          
    #  end                                              



    class ClassName < DelegateClass(ParentClass)
        def initialize
            super(delegate object)
    
            
        end
    end

    class ClassNameTYPED < DelegateClass(ParentClassTYPED)
        def initialize(arg_TYPED, narg_TYPED, narg_TYPED)
            super(delegateobject_TYPED)
    
            
        end
    end b

    a class ClassName < DelegateClass(ParentClass)
        def initialize
            super(delegate object)
    
            
        end
    end b

    a class ClassName < DelegateClass(ParentClass)
        def initialize
            super(delegate object)
    
            
        end
    end


    #   -------------cli--------------- 
    #  class `ClassName^                
    #      `init^`                      
    #      `def...^                     
    #                                   
    #      `def^`                       
    #      `def...^                     
    #  end                              



    class ClassName
        def initialize
            
        end
        
        def method
            
        end
    end

    class ClassNameTYPED
        def initialize(arg_TYPED, narg_TYPED, narg_TYPED)
            cursor_TYPED
        end
        def_TYPED
    end b

    a class ClassName
        def initialize
            
        end
        
        def method
            
        end
    end b

    a class ClassName
        def initialize
            
        end
        
        def method
            
        end
    end


    #   -------------cls--------------- 
    #  class << `self^                  
    #      `cursor^                     
    #  end                              



    class << self
        
    end

    class << self_TYPED
        
    end b

    a class << self
        
    end b

    a class << self
        
    end


    #   -------------clstr---------------            
    #  `ClassName^ = Struct.new`(:`attr*`)^` `do...^ 



    ClassName = Struct.new do
        
    end

    ClassNameTYPED = Struct.new(:attr_TYPED, :nattr_TYPED, :nattr_TYPED) do_TYPED b

    a ClassName = Struct.new do
        
    end b

    a ClassName = Struct.new do
        
    end


    #   -------------col--------------- 
    #  collect { |`obj^| `cursor^ }     



    collect { |obj|  }

    collect { |obj_TYPED|  } b

    a collect { |obj|  } b

    a collect { |obj|  }


    #   -------------Comp--------------- 
    #  include Comparable                
    #                                    
    #  def <=>(other)                    
    #      `cursor^                      
    #  end                               



    include Comparable
    
    def <=>(other)
        
    end

    include Comparable
    
    def <=>(other)
        
    end b

    a include Comparable
    
    def <=>(other)
        
    end b

    a include Comparable
    
    def <=>(other)
        
    end


    #   -------------deec--------------- 
    #  Marshal.load(Marshal.dump(`obj^)) 



    Marshal.load(Marshal.dump(obj))

    Marshal.load(Marshal.dump(obj_TYPED)) b

    a Marshal.load(Marshal.dump(obj)) b

    a Marshal.load(Marshal.dump(obj))


    #   -------------def--------------- 
    #  def `method^`(`arg*`)^           
    #      `cursor^                     
    #  end                              



    def method
        
    end

    def method_TYPED(arg_TYPED, narg_TYPED, narg_TYPED)
        
    end b

    a def method
        
    end b

    a def method
        
    end


    #   -------------def_--------------- 
    #  def `method_name^`(`arg*`)^       
    #      `wrapped^                     
    #  end                               



def method_name
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
end

def method_name_TYPED(arg_TYPED, narg_TYPED, narg_TYPED)
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
endb

a def method_name
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
endb

a def method_name
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
end


    #   -------------defd---------------                  
    #  def_delegator :`del obj^, :`del meth^, :`new name^ 



    def_delegator :del obj, :del meth, :new name

    def_delegator :delobj_TYPED, :delmeth_TYPED, :new name b

    a def_delegator :del obj, :del meth, :new name b

    a def_delegator :del obj, :del meth, :new name


    #   -------------defds---------------        
    #  def_delegators :`del obj^, :`del methods^ 



    def_delegators :del obj, :del methods

    def_delegators :delobj_TYPED, :del methods b

    a def_delegators :del obj, :del methods b

    a def_delegators :del obj, :del methods


    #   -------------defi--------------- 
    #  def initialize`(`arg*`)^          
    #      `cursor^                      
    #  end                               



    def initialize
        
    end

    def initialize(arg_TYPED, narg_TYPED, narg_TYPED)
        
    end b

    a def initialize
        
    end b

    a def initialize
        
    end


    #   -------------defmm---------------      
    #  def method_missing(meth, *args, &block) 
    #      `cursor^                            
    #  end                                     



    def method_missing(meth, *args, &block)
        
    end

    def method_missing(meth, *args, &block)
        
    end b

    a def method_missing(meth, *args, &block)
        
    end b

    a def method_missing(meth, *args, &block)
        
    end


    #   -------------defs--------------- 
    #  def self.`method^`(`arg*`)^       
    #      `cursor^                      
    #  end                               



    def self.method
        
    end

    def self.method_TYPED(arg_TYPED, narg_TYPED, narg_TYPED)
        
    end b

    a def self.method
        
    end b

    a def self.method
        
    end


    #   -------------deft--------------- 
    #  def test_`name^                   
    #      `cursor^                      
    #  end                               



    def test_name
        
    end

    def test_name_TYPED
        
    end b

    a def test_name
        
    end b

    a def test_name
        
    end


    #   -------------deli--------------- 
    #  delete_if { |`arg^| `cursor^ }    



    delete_if { |arg|  }

    delete_if { |arg_TYPED|  } b

    a delete_if { |arg|  } b

    a delete_if { |arg|  }


    #   -------------det--------------- 
    #  detect { |`obj^| `cursor^ }      



    detect { |obj|  }

    detect { |obj_TYPED|  } b

    a detect { |obj|  } b

    a detect { |obj|  }


    #   -------------dir--------------- 
    #  Dir[`_^]                         



    Dir['/**/*']

    Dir[__TYPED] b

    a Dir['/**/*'] b

    a Dir['/**/*']


    #   -------------dirg---------------     
    #  Dir.glob(`dir^) { |`file^| `cursor^ } 



    Dir.glob(dir) { |file|  }

    Dir.glob(dir_TYPED) { |file_TYPED|  } b

    a Dir.glob(dir) { |file|  } b

    a Dir.glob(dir) { |file|  }


    #   -------------do--------------- 
    #  do` |`arg*`|^                   
    #      `cursor^                    
    #  end                             



    do
        
    end

    do |arg_TYPED, narg_TYPED, narg_TYPED|
        
    end b

    a do
        
    end b

    a do
        
    end


    #   -------------dow---------------      
    #  downto(`lbound^) { |`arg^| `cursor^ } 



    downto(0) { |i|  }

    downto(lbound_TYPED) { |arg_TYPED|  } b

    a downto(0) { |i|  } b

    a downto(0) { |i|  }


    #   -------------each---------------  
    #  each`_`what^ { |`vars^| `cursor^ } 



    each_byte { |byte|  }

    each_byte { |byte_TYPED|  } b

    a each_byte { |byte|  } b

    a each_byte { |byte|  }


    #   -------------Email--------------- 
    #  `$email^                           



    drdr.xp@gmail.com

    drdr.xp@gmail.com b

    a drdr.xp@gmail.com b

    a drdr.xp@gmail.com


    #   -------------END--------------- 
    #  END {                            
    #      `cursor^                     
    #  }                                



    END {
        
    }

    END {
        
    } b

    a END {
        
    } b

    a END {
        
    }


    #   -------------Enum--------------- 
    #  include Enumerable                
    #                                    
    #  def each(&block)                  
    #      `cursor^                      
    #  end                               



    include Enumerable
    
    def each(&block)
        
    end

    include Enumerable
    
    def each(&block)
        
    end b

    a include Enumerable
    
    def each(&block)
        
    end b

    a include Enumerable
    
    def each(&block)
        
    end


    #   -------------fdir--------------- 
    #  File.dirname(`^)                  



    File.dirname()

    File.dirname(_TYPED) b

    a File.dirname() b

    a File.dirname()


    #   -------------fet---------------   
    #  fetch(`name^) { |`key^| `cursor^ } 



    fetch(name) { |key|  }

    fetch(name_TYPED) { |key_TYPED|  } b

    a fetch(name) { |key|  } b

    a fetch(name) { |key|  }


    #   -------------file---------------                
    #  File.foreach('`filename^') { |`line^| `cursor^ } 



    File.foreach('filename') { |line|  }

    File.foreach('filename_TYPED') { |line_TYPED|  } b

    a File.foreach('filename') { |line|  } b

    a File.foreach('filename') { |line|  }


    #   -------------File--------------- 
    #  `file()^                          



    test.page

    test.page b

    a test.page b

    a test.page


    #   -------------fin--------------- 
    #  find { |`element^| `cursor^ }    



    find { |element|  }

    find { |element_TYPED|  } b

    a find { |element|  } b

    a find { |element|  }


    #   -------------fina--------------- 
    #  find_all { |`element^| `cursor^ } 



    find_all { |element|  }

    find_all { |element_TYPED|  } b

    a find_all { |element|  } b

    a find_all { |element|  }


    #   -------------fjoin--------------- 
    #  File.join(`dir^, `path^)           



    File.join(dir, path)

    File.join(dir_TYPED, path_TYPED) b

    a File.join(dir, path) b

    a File.join(dir, path)


    #   -------------fla---------------                    
    #  inject(Array.new) { |`arr^, `a^| `arr^.push(*`a^) } 



    inject(Array.new) { |arr, a| arr.push(*a) }

    inject(Array.new) { |arr_TYPED, a_TYPED| arr_TYPED.push(*a_TYPED) } b

    a inject(Array.new) { |arr, a| arr.push(*a) } b

    a inject(Array.new) { |arr, a| arr.push(*a) }


    #   -------------Forw--------------- 
    #  extend Forwardable                



    extend Forwardable

    extend Forwardable b

    a extend Forwardable b

    a extend Forwardable


    #   -------------fread--------------- 
    #  File.read(`filename^)              



    File.read(filename)

    File.read(filename_TYPED) b

    a File.read(filename) b

    a File.read(filename)


    #   -------------grep---------------        
    #  grep(/`pattern^/) { |`match^| `cursor^ } 



    grep(/pattern/) { |match|  }

    grep(/pattern_TYPED/) { |match_TYPED|  } b

    a grep(/pattern/) { |match|  } b

    a grep(/pattern/) { |match|  }


    #   -------------gsub---------------        
    #  gsub(/`pattern^/) { |`match^| `cursor^ } 



    gsub(/pattern/) { |match|  }

    gsub(/pattern_TYPED/) { |match_TYPED|  } b

    a gsub(/pattern/) { |match|  } b

    a gsub(/pattern/) { |match|  }


    #   -------------hash---------------                    
    #  Hash.new { |`hash^,`key^| `hash^[`key^] = `cursor^ } 



    Hash.new { |hash,key| hash[key] =  }

    Hash.new { |hash_TYPED,key_TYPED| hash_TYPED[key_TYPED] =  } b

    a Hash.new { |hash,key| hash[key] =  } b

    a Hash.new { |hash,key| hash[key] =  }


    #   -------------if--------------- 
    #  if `boolean exp^                
    #      `cursor^                    
    #  end                             



    if boolean exp
        
    end

    if booleanexp_TYPED
        
    end b

    a if boolean exp
        
    end b

    a if boolean exp
        
    end


    #   -------------ife--------------- 
    #  if `boolean exp^                 
    #      `block^                      
    #  else                             
    #      `cursor^                     
    #  end                              



    if boolean exp
        # block
    else
        
    end

    if booleanexp_TYPED
        block_TYPED
    else
        
    end b

    a if boolean exp
        # block
    else
        
    end b

    a if boolean exp
        # block
    else
        
    end


    #   -------------ifei--------------- 
    #  if `boolean exp^`                 
    #      `block^                       
    #  ``elsif...`                       
    #  {{^elsif `comparison^             
    #      `block^                       
    #  ``elsif...`                       
    #  ^`}}^``else...`                   
    #  {{^else                           
    #      `cursor^                      
    #  `}}^end                           



    if boolean exp
        # block
    elsif comparison
        # block
    elsif comparison
        # block
    elsif comparison
        # block
    else
        
    end

    if booleanexp_TYPED
        block_TYPED
    elsif_TYPED
    else_TYPED
    end b

    a if boolean exp
        # block
    elsif comparison
        # block
    elsif comparison
        # block
    elsif comparison
        # block
    else
        
    end b

    a if boolean exp
        # block
    elsif comparison
        # block
    elsif comparison
        # block
    elsif comparison
        # block
    else
        
    end


    #   -------------inj---------------                        
    #  inject`(`arg`)^ { |`accumulator^, `element^| `cursor^ } 



    inject(arg) { |accumulator, element|  }

    inject(arg_TYPED) { |accumulator_TYPED, element_TYPED|  } b

    a inject(arg) { |accumulator, element|  } b

    a inject(arg) { |accumulator, element|  }


    #   -------------invoke_--------------- 
    #  `name^(`wrapped^)                    



name(WRAPPED_TEXT
WRAPPED_TEXT_line2)

name_TYPED(WRAPPED_TEXT
WRAPPED_TEXT_line2)b

a name(WRAPPED_TEXT
WRAPPED_TEXT_line2)b

a name(WRAPPED_TEXT
WRAPPED_TEXT_line2)


    #   -------------lam--------------- 
    #  lambda {` |`arg*`|^ `cursor^ }   



    lambda {  }

    lambda { |arg_TYPED, narg_TYPED, narg_TYPED|  } b

    a lambda {  } b

    a lambda {  }


    #   -------------loop--------------- 
    #  loop do                           
    #      `cursor^                      
    #  end                               



    loop do
        
    end

    loop do
        
    end b

    a loop do
        
    end b

    a loop do
        
    end


    #   -------------map--------------- 
    #  map { |`arg^| `cursor^ }         



    map { |arg|  }

    map { |arg_TYPED|  } b

    a map { |arg|  } b

    a map { |arg|  }


    #   -------------max---------------          
    #  max { |`element1^, `element2^| `cursor^ } 



    max { |element1, element2|  }

    max { |element1_TYPED, element2_TYPED|  } b

    a max { |element1, element2|  } b

    a max { |element1, element2|  }


    #   -------------Md---------------                                      
    #  File.open(`filename^, "wb") { |`file^| Marshal.dump(`obj^, `file^) } 



    File.open(filename, "wb") { |file| Marshal.dump(obj, file) }

    File.open(filename_TYPED, "wb") { |file_TYPED| Marshal.dump(obj_TYPED, file_TYPED) } b

    a File.open(filename, "wb") { |file| Marshal.dump(obj, file) } b

    a File.open(filename, "wb") { |file| Marshal.dump(obj, file) }


    #   -------------min---------------          
    #  min { |`element1^, `element2^| `cursor^ } 



    min { |element1, element2|  }

    min { |element1_TYPED, element2_TYPED|  } b

    a min { |element1, element2|  } b

    a min { |element1, element2|  }


    #   -------------Ml---------------                               
    #  File.open(`filename^, "rb") { |`file^| Marshal.load(`file^) } 



    File.open(filename, "rb") { |file| Marshal.load(file) }

    File.open(filename_TYPED, "rb") { |file_TYPED| Marshal.load(file_TYPED) } b

    a File.open(filename, "rb") { |file| Marshal.load(file) } b

    a File.open(filename, "rb") { |file| Marshal.load(file) }


    #   -------------mod--------------- 
    #  module `module name^             
    #      `cursor^                     
    #  end                              



    module ModuleName
        
    end

    module ModulenameTYPED
        
    end b

    a module ModuleName
        
    end b

    a module ModuleName
        
    end


    #   -------------modf--------------- 
    #  module `module name^              
    #      module_function               
    #                                    
    #      `cursor^                      
    #  end                               



    module ModuleName
        module_function
    
        
    end

    module ModulenameTYPED
        module_function
    
        
    end b

    a module ModuleName
        module_function
    
        
    end b

    a module ModuleName
        module_function
    
        
    end


    #   -------------module_--------------- 
    #  module `_^                           
    #      `wrapped^                        
    #  end                                  



module 
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
end

module TYPED
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
endb

a module 
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
endb

a module 
    WRAPPED_TEXT
    WRAPPED_TEXT_line2
end


    #   -------------nam--------------- 
    #  namespace :`ns^ do               
    #      `cursor^                     
    #  end                              



    namespace :test do
        
    end

    namespace :ns_TYPED do
        
    end b

    a namespace :test do
        
    end b

    a namespace :test do
        
    end


    #   -------------new--------------- 
    #  `var^ = `Object^.new`(`arg*`)^   



    var = Object.new

    var_TYPED = ObjectTYPED.new(arg_TYPED, narg_TYPED, narg_TYPED) b

    a var = Object.new b

    a var = Object.new


    #   -------------open---------------                
    #  open(`filename^`, `mode...^) { |`io^| `cursor^ } 



    open(filename, 'wb') { |io|  }

    open(filename_TYPED, mode_TYPED) { |io_TYPED|  } b

    a open(filename, 'wb') { |io|  } b

    a open(filename, 'wb') { |io|  }


    #   -------------par---------------   
    #  partition { |`element^| `cursor^ } 



    partition { |element|  }

    partition { |element_TYPED|  } b

    a partition { |element|  } b

    a partition { |element|  }


    #   -------------pathf---------------          
    #  File.join(File.dirname(__FILE__), "`path^") 



    File.join(File.dirname(__FILE__), "../lib")

    File.join(File.dirname(__FILE__), "path_TYPED") b

    a File.join(File.dirname(__FILE__), "../lib") b

    a File.join(File.dirname(__FILE__), "../lib")


    #   -------------Pn--------------- 
    #  PStore.new(`filename^)          



    PStore.new(filename)

    PStore.new(filename_TYPED) b

    a PStore.new(filename) b

    a PStore.new(filename)


    #   -------------rej--------------- 
    #  reject { |`element^| `cursor^ }  



    reject { |element|  }

    reject { |element_TYPED|  } b

    a reject { |element|  } b

    a reject { |element|  }


    #   -------------rep---------------                       
    #  result.report("`name^: ") { TESTS.times { `cursor^ } } 



    result.report("name: ") { TESTS.times {  } }

    result.report("name_TYPED: ") { TESTS.times {  } } b

    a result.report("name: ") { TESTS.times {  } } b

    a result.report("name: ") { TESTS.times {  } }


    #   -------------req--------------- 
    #  require '`lib^'                  



    require 'lib'

    require 'lib_TYPED' b

    a require 'lib' b

    a require 'lib'


    #   -------------reqs---------------    
    #  %w[`lib*^].map { |lib| require lib } 



    %w[].map { |lib| require lib }
    

    %w[lib_TYPED lib_TYPED lib_TYPED].map { |lib| require lib }
     b

     a %w[].map { |lib| require lib }
      b

      a %w[].map { |lib| require lib }
      


    #   -------------reve---------------     
    #  reverse_each { |`element^| `cursor^ } 



    reverse_each { |element|  }

    reverse_each { |element_TYPED|  } b

    a reverse_each { |element|  } b

    a reverse_each { |element|  }


    #   -------------ruby--------------- 
    #  #!/usr/bin/env ruby               
    #  _CMT_-*- encoding: `enc^ -*-      



    #!/usr/bin/env ruby
    # -*- encoding: utf-8 -*-
    #
    #!/usr/bin/env ruby
    # -*- encoding: enc_TYPED -*- b
    #
    a #!/usr/bin/env ruby
    # -*- encoding: utf-8 -*- b
    #
    a #!/usr/bin/env ruby
    # -*- encoding: utf-8 -*-
    #

    #   -------------sb--------------- 
    #  #!/usr/bin/env ruby             
    #  _CMT_-*- encoding: `enc^ -*-    



    #!/usr/bin/env ruby
    # -*- encoding: utf-8 -*-
    #
    #!/usr/bin/env ruby
    # -*- encoding: enc_TYPED -*- b
    #
    a #!/usr/bin/env ruby
    # -*- encoding: utf-8 -*- b
    #
    a #!/usr/bin/env ruby
    # -*- encoding: utf-8 -*-
    #

    #   -------------scan---------------        
    #  scan(/`pattern^/) { |`match^| `cursor^ } 



    scan(/pattern/) { |match|  }

    scan(/pattern_TYPED/) { |match_TYPED|  } b

    a scan(/pattern/) { |match|  } b

    a scan(/pattern/) { |match|  }


    #   -------------sel--------------- 
    #  select { |`element^| `cursor^ }  



    select { |element|  }

    select { |element_TYPED|  } b

    a select { |element|  } b

    a select { |element|  }


    #   -------------shebang--------------- 
    #  #!/usr/bin/env ruby                  
    #  _CMT_-*- encoding: `enc^ -*-         



    #!/usr/bin/env ruby
    # -*- encoding: utf-8 -*-
    #
    #!/usr/bin/env ruby
    # -*- encoding: enc_TYPED -*- b
    #
    a #!/usr/bin/env ruby
    # -*- encoding: utf-8 -*- b
    #
    a #!/usr/bin/env ruby
    # -*- encoding: utf-8 -*-
    #

    #   -------------sinc--------------- 
    #  class << self; self; end          



    class << self; self; end

    class << self; self; end b

    a class << self; self; end b

    a class << self; self; end


    #   -------------sor---------------                            
    #  sort { |`element1^, `element2^| `element1^ <=> `element2^ } 



    sort { |element1, element2| element1 <=> element2 }

    sort { |element1_TYPED, element2_TYPED| element1_TYPED <=> element2_TYPED } b

    a sort { |element1, element2| element1 <=> element2 } b

    a sort { |element1, element2| element1 <=> element2 }


    #   -------------sorb--------------- 
    #  sort_by {` |`arg`|^ `cursor^ }    



    sort_by { |arg|  }

    sort_by { |arg_TYPED|  } b

    a sort_by { |arg|  } b

    a sort_by { |arg|  }


    #   -------------ste---------------          
    #  step(`count^`, `step^) { |`i^| `cursor^ } 



    step(count, step) { |i|  }

    step(count_TYPED, step_TYPED) { |i_TYPED|  } b

    a step(count, step) { |i|  } b

    a step(count, step) { |i|  }


    #   -------------sub---------------        
    #  sub(/`pattern^/) { |`match^| `cursor^ } 



    sub(/pattern/) { |match|  }

    sub(/pattern_TYPED/) { |match_TYPED|  } b

    a sub(/pattern/) { |match|  } b

    a sub(/pattern/) { |match|  }


    #   -------------subcl--------------- 
    #  class `ClassName^ < `Parent^       
    #      `cursor^                       
    #  end                                



    class ClassName < Parent
        
    end

    class ClassNameTYPED < ParentTYPED
        
    end b

    a class ClassName < Parent
        
    end b

    a class ClassName < Parent
        
    end


    #   -------------tas---------------    
    #  desc "`task description^"           
    #  task :`task name^` => [:`dep*`]^ do 
    #      `cursor^                        
    #  end                                 



    desc "task description"
    task :task_name do
        
    end

    desc "taskdescription_TYPED"
    task :taskname_TYPED => [:dep_TYPED, :ndep_TYPED, :ndep_TYPED] do
        
    end b

    a desc "task description"
    task :task_name do
        
    end b

    a desc "task description"
    task :task_name do
        
    end


    #   -------------tc---------------              
    #  require "test/unit"                          
    #  require "`module^"                           
    #                                               
    #  class Test`ClassName^ < Test::Unit::TestCase 
    #      `deft^`                                  
    #                                               
    #      `deft...`{{^                             
    #                                               
    #      `deft^`                                  
    #                                               
    #      `deft...`^`}}^                           
    #  end                                          



    require "test/unit"
    require "module"
    
    class TestModule < Test::Unit::TestCase
        def test_name
            
        end
        
        def test_name
            
        end
        
        def test_name
            
        end
        
        def test_name
            
        end
    end

    require "test/unit"
    require "module_TYPED"
    
    class TestClassNameTYPED < Test::Unit::TestCase
        def test_name_TYPED
            cursor_TYPED
        end 
    
        deft_TYPED
    end b

    a require "test/unit"
    require "module"
    
    class TestModule < Test::Unit::TestCase
        def test_name
            
        end
        
        def test_name
            
        end
        
        def test_name
            
        end
        
        def test_name
            
        end
    end b

    a require "test/unit"
    require "module"
    
    class TestModule < Test::Unit::TestCase
        def test_name
            
        end
        
        def test_name
            
        end
        
        def test_name
            
        end
        
        def test_name
            
        end
    end


    #   -------------tif---------------                 
    #  (`boolean exp^) ? `exp if true^ : `exp if false^ 



    (boolean exp) ? exp if true : exp if false

    (booleanexp_TYPED) ? expiftrue_TYPED : exp if false b

    a (boolean exp) ? exp if true : exp if false b

    a (boolean exp) ? exp if true : exp if false


    #   -------------tim--------------- 
    #  times {` |`i`|^ `cursor^ }       



    times { |i|  }

    times { |i_TYPED|  } b

    a times { |i|  } b

    a times { |i|  }


    #   -------------tra--------------- 
    #  transaction(`true^) { `cursor^ } 



    transaction(true) {  }

    transaction(true_TYPED) {  } b

    a transaction(true) {  } b

    a transaction(true) {  }


    #   -------------unif--------------- 
    #  ARGF.each_line do |`line^|        
    #      `cursor^                      
    #  end                               



    ARGF.each_line do |line|
        
    end

    ARGF.each_line do |line_TYPED|
        
    end b

    a ARGF.each_line do |line|
        
    end b

    a ARGF.each_line do |line|
        
    end


    #   -------------unless--------------- 
    #  unless `boolean cond^               
    #      `cursor^                        
    #  end                                 



    unless boolean cond
        
    end

    unless booleancond_TYPED
        
    end b

    a unless boolean cond
        
    end b

    a unless boolean cond
        
    end


    #   -------------until--------------- 
    #  until `boolean cond^               
    #      `cursor^                       
    #  end                                



    until boolean cond
        
    end

    until booleancond_TYPED
        
    end b

    a until boolean cond
        
    end b

    a until boolean cond
        
    end


    #   -------------upt---------------  
    #  upto(`ubound^) { |`i^| `cursor^ } 



    upto(ubound) { |i|  }

    upto(ubound_TYPED) { |i_TYPED|  } b

    a upto(ubound) { |i|  } b

    a upto(ubound) { |i|  }


    #   -------------usai---------------          
    #  if ARGV`^                                  
    #      abort "Usage: #{$PROGRAM_NAME} `args^" 
    #  end                                        



    if ARGV
        abort "Usage: #{$PROGRAM_NAME} [options]"
    end

    if ARGV_TYPED 
        abort "Usage: #{$PROGRAM_NAME} args_TYPED"
    end b

    a if ARGV 
        abort "Usage: #{$PROGRAM_NAME} [options]"
    end b

    a if ARGV
        abort "Usage: #{$PROGRAM_NAME} [options]"
    end


    #   -------------usau---------------          
    #  unless ARGV`^                              
    #      abort "Usage: #{$PROGRAM_NAME} `args^" 
    #  end                                        



    unless ARGV
        abort "Usage: #{$PROGRAM_NAME} [options]"
    end

    unless ARGV_TYPED 
        abort "Usage: #{$PROGRAM_NAME} args_TYPED"
    end b

    a unless ARGV 
        abort "Usage: #{$PROGRAM_NAME} [options]"
    end b

    a unless ARGV
        abort "Usage: #{$PROGRAM_NAME} [options]"
    end


    #   -------------while--------------- 
    #  while `boolean cond^               
    #      `cursor^                       
    #  end                                



    while boolean cond
        
    end

    while booleancond_TYPED
        
    end b

    a while boolean cond
        
    end b

    a while boolean cond
        
    end


    #   -------------wid---------------             
    #  with_index { |`element^, `index^| `cursor^ } 



    with_index { |element, index|  }

    with_index { |element_TYPED, index_TYPED|  } b

    a with_index { |element, index|  } b

    a with_index { |element, index|  }


    #   -------------xml---------------           
    #  REXML::Document.new(File.read(`filename^)) 



    REXML::Document.new(File.read(filename))

    REXML::Document.new(File.read(filename_TYPED)) b

    a REXML::Document.new(File.read(filename)) b

    a REXML::Document.new(File.read(filename))


    #   -------------Yd---------------                                         
    #  File.open("`filename^.yaml", "wb") { |`file^| YAML.dump(`obj^,`file^) } 



    File.open("filename.yaml", "wb") { |file| YAML.dump(obj,file) }

    File.open("filename_TYPED.yaml", "wb") { |file_TYPED| YAML.dump(obj_TYPED,file_TYPED) } b

    a File.open("filename.yaml", "wb") { |file| YAML.dump(obj,file) } b

    a File.open("filename.yaml", "wb") { |file| YAML.dump(obj,file) }


    #   -------------Yl---------------                             
    #  File.open("`filename^.yaml") { |`file^| YAML.load(`file^) } 



    File.open("filename.yaml") { |file| YAML.load(file) }

    File.open("filename_TYPED.yaml") { |file_TYPED| YAML.load(file_TYPED) } b

    a File.open("filename.yaml") { |file| YAML.load(file) } b

    a File.open("filename.yaml") { |file| YAML.load(file) }


    #   -------------zip--------------- 
    #  zip(`enum^) { |`row^| `cursor^ } 



    zip(enum) { |row|  }

    zip(enum_TYPED) { |row_TYPED|  } b

    a zip(enum) { |row|  } b

    a zip(enum) { |row|  }


    #   -------------{_--------------- 
    #  {`wrapped^}                     



{WRAPPED_TEXT
WRAPPED_TEXT_line2}

{WRAPPED_TEXT
WRAPPED_TEXT_line2}b

a {WRAPPED_TEXT
WRAPPED_TEXT_line2}b

a {WRAPPED_TEXT
WRAPPED_TEXT_line2}

